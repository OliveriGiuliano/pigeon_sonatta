# Video-to-MIDI Converter: Unified Video Pipeline Refactor

## Objective
Refactor the existing video processing system from a dual-decode architecture (VLC + OpenCV) to a unified single-decode pipeline using PyAV (FFmpeg Python bindings) for better performance, synchronization, and resource efficiency.

## Current Architecture Issues
- Dual video decoding (VLC for display, CV2 for processing)
- Synchronization problems between display and processing
- Resource waste and potential frame drops
- Complex timing coordination

## Target Architecture
```
Video File → PyAV Decoder → Frame Queue → [Display Thread + Processing Thread]
```

## Required Changes

### 1. Replace video.py with PyAV Implementation

**New VideoManager Requirements:**
- Use PyAV for video decoding instead of python-vlc
- Implement frame queue system for thread-safe frame sharing
- Create separate threads for:
  - Video decoding (producer)
  - Frame display (consumer)
  - Frame processing (consumer)
- Maintain existing interface for backward compatibility
- Maintain all existing features

**Key Features to Implement:**
```python
class VideoManager:
    def __init__(self, video_panel, frame_callback=None):
        # Initialize PyAV container and streams
        # Set up frame queues (display_queue, processing_queue)
        # Create threading infrastructure
        
    def open(self, path):
        # Open video with PyAV
        # Detect video properties (fps, resolution, codec)
        # Start decoder thread
        
    def play(self):
        # Start display and processing threads
        # Begin frame production
        
    def pause(self):
        # Pause frame production
        # Maintain current position
        
    def _decoder_thread(self):
        # Main decoding loop
        # Read frames from PyAV
        # Push to both display and processing queues
        
    def _display_thread(self):
        # Display frames on Tkinter canvas/label
        # Handle frame rate limiting
        
    def get_time(self):
        # Return current playback position
        
    def get_fps(self):
        # Return video framerate from PyAV metadata
```

### 2. Update Display System

**Replace VLC embedding with Tkinter-based display:**
- Use `tkinter.Label` with PhotoImage for frame display
- Or use `tkinter.Canvas` for more control
- Handle frame scaling and aspect ratio
- Optimize for smooth playback (consider PIL/Pillow optimizations)

**Display optimizations to implement:**
- Frame format conversion (YUV→RGB efficiently)
- Image scaling using high-performance libraries (PIL-SIMD if available)
- Double buffering for smooth updates

### 3. Frame Processing Integration

**Modify audio.py integration:**
- Remove CV2 file reading from `get_current_frame_from_file()`
- Receive frames directly from VideoManager frame queue
- Ensure thread safety in frame processing
- Handle frame queue overflow (drop old frames if processing can't keep up)

### 4. Threading Architecture

**Implement robust threading system:**
```python
# Queue sizes to prevent memory bloat
DISPLAY_QUEUE_SIZE = 5
PROCESSING_QUEUE_SIZE = 10

# Thread coordination
class VideoManager:
    def __init__(self):
        self.display_queue = queue.Queue(maxsize=DISPLAY_QUEUE_SIZE)
        self.processing_queue = queue.Queue(maxsize=PROCESSING_QUEUE_SIZE)
        self.decoder_thread = None
        self.display_thread = None
        self.stop_event = threading.Event()
```

### 5. Error Handling and Resilience

**Implement comprehensive error handling:**
- Container/stream opening failures
- Codec not supported scenarios
- Threading errors and cleanup
- Frame queue overflow handling
- Memory management for large videos

### 6. Performance Optimizations

**Hardware Acceleration (if available):**
```python
# Try to enable hardware decoding
container = av.open(filename)
video_stream = container.streams.video[0]
if video_stream.codec_context:
    video_stream.codec_context.thread_count = 0  # Auto-detect
    # Try hardware acceleration
    try:
        video_stream.codec_context.hw_acceleration = 'auto'
    except:
        pass  # Fall back to software decoding
```

**Memory Management:**
- Limit queue sizes to prevent memory bloat
- Efficient frame format conversion
- Proper cleanup of PyAV resources

### 7. Maintain Existing Interface

**Preserve compatibility with window.py:**
- Keep existing method signatures where possible
- Maintain callback system for frame processing
- Preserve timing/stats functionality
- Keep existing error handling patterns

## Dependencies to Add
```bash
pip install av  # PyAV for FFmpeg bindings
pip install Pillow  # For efficient image processing
```

## Testing Requirements

**Verify the following functionality:**
1. Video playback smooth and synchronized
2. Frame processing maintains accuracy
3. Play/pause/stop controls work correctly
4. Audio generation remains synchronized
5. No memory leaks during long playback sessions
6. Proper cleanup on application exit

## Fallback Strategy

If PyAV proves problematic:
1. Try imageio-ffmpeg as alternative
2. Consider opencv-python with threading optimizations
3. Implement frame caching to reduce decode overhead

## Implementation Priority

1. **Phase 1**: Basic PyAV integration with simple display
2. **Phase 2**: Threading and queue system
3. **Phase 3**: Performance optimizations and hardware acceleration
4. **Phase 4**: Error handling and edge cases
5. **Phase 5**: Testing and refinement

## Notes for Implementation

- Focus on maintaining the existing grid visualization functionality
- Preserve all current UI controls and their behavior
- Ensure frame processing callback system continues to work
- Pay special attention to cleanup and resource management
- Test with various video formats and sizes
- Consider frame dropping strategies if processing can't keep up